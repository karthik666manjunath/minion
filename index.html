<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Minion Translator</title>
  <style>
    :root {
      --bg-1: #fff4c1;
      --bg-2: #ffd36a;
      --ink: #1b1b1b;
      --accent: #2a78ff;
      --card: #ffffff;
      --shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Trebuchet MS", "Verdana", sans-serif;
      color: var(--ink);
      background:
        linear-gradient(120deg, rgba(255, 244, 193, 0.45), rgba(255, 211, 106, 0.35)),
        url("kevin.png") left 6% bottom 0% / min(55vw, 420px) auto no-repeat,
        radial-gradient(circle at 20% 20%, #fff9dd 0%, var(--bg-1) 35%, var(--bg-2) 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .page {
      width: 100%;
      max-width: 960px;
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 28px;
      align-items: center;
    }

    .hero {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #111111;
      color: #ffffff;
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      width: fit-content;
    }

    h1 {
      font-size: clamp(32px, 5vw, 56px);
      margin: 0;
      line-height: 1.05;
    }

    p {
      margin: 0;
      font-size: 16px;
      line-height: 1.6;
    }

    .card {
      background: var(--card);
      padding: 22px;
      border-radius: 20px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      border-radius: 14px;
      border: 2px solid #f2f2f2;
      padding: 14px;
      font-size: 16px;
      resize: vertical;
      font-family: inherit;
      outline: none;
    }

    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(42, 120, 255, 0.15);
    }

    .actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }

    .actions .secondary {
      padding: 10px 14px;
      font-size: 14px;
    }

    .btn-icon {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .output-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }

    button {
      border: none;
      background: var(--accent);
      color: white;
      padding: 12px 18px;
      border-radius: 12px;
      font-size: 15px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button.secondary {
      background: #ffe499;
      color: #1b1b1b;
    }

    button:active {
      transform: scale(0.98);
    }

    .output {
      background: #fff8d8;
      border-radius: 14px;
      padding: 14px;
      min-height: 120px;
      font-size: 16px;
      line-height: 1.6;
      border: 2px dashed #f4d67a;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .output-block label {
      display: inline-block;
      margin-bottom: 8px;
    }

    .hint {
      font-size: 13px;
      color: #4d4d4d;
    }

    @media (max-width: 820px) {
      .page {
        grid-template-columns: 1fr;
      }

      .card {
        order: 2;
      }
    }
  </style>
</head>
<body>
  <main class="page">
    <section class="hero">
      <div class="badge">Minion Translator</div>
      <h1>Turn your words into Minion language.</h1>
      <p>
        Paste any sentence and the translator will switch it into a playful
        Minion-style dialect. Works instantly, no signup required.
      </p>
      <p class="hint">Tip: Try "Hello! I'm hungry."</p>
    </section>

    <section class="card">
      <label for="input">Your text</label>
      <textarea id="input" placeholder="Tip: Try &quot;Hello! I'm hungry.&quot;"></textarea>
      <div class="actions">
        <button id="translate" class="btn-icon">
          <span class="icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" width="18" height="18" role="img" focusable="false">
              <path d="M12 3a1 1 0 0 1 1 1v2h5a1 1 0 1 1 0 2h-1.3a11.6 11.6 0 0 1-2.7 5 12 12 0 0 1 2.46 2.55 1 1 0 0 1-1.62 1.16A10 10 0 0 0 12 13.53a10 10 0 0 1-3.84 3.37 1 1 0 0 1-.9-1.8A8 8 0 0 0 10.47 12H7a1 1 0 1 1 0-2h4V4a1 1 0 0 1 1-1Zm7.15 17H14l-1.1 2.3a1 1 0 0 1-1.8-.86l4-8.5a1 1 0 0 1 1.8 0l4 8.5a1 1 0 1 1-1.8.86L19.15 20Zm-1-2-1.45-3.1L15.24 18h2.91Z" fill="currentColor"/>
            </svg>
          </span>
          Translate
        </button>
        <button id="clear" class="secondary">Clear</button>
      </div>
      <div class="output-block">
        <label for="output">Minion language</label>
        <div id="output" class="output" aria-live="polite"></div>
        <div class="output-actions">
          <button id="copy" class="secondary">Copy</button>
          <button id="speak" aria-label="Speak">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" width="18" height="18" role="img" focusable="false">
                <path d="M11 5a2 2 0 0 1 2 2v10a2 2 0 1 1-4 0V7a2 2 0 0 1 2-2Zm-6 7a1 1 0 0 1 2 0 4 4 0 0 0 8 0 1 1 0 1 1 2 0 6 6 0 0 1-5 5.92V20a1 1 0 1 1-2 0v-2.08A6 6 0 0 1 5 12Z" fill="currentColor"/>
              </svg>
            </span>
            Speak
          </button>
        </div>
      </div>
    </section>
  </main>

  <script>
    const input = document.getElementById("input");
    const output = document.getElementById("output");
    const translateBtn = document.getElementById("translate");
    const speakBtn = document.getElementById("speak");
    const copyBtn = document.getElementById("copy");
    const clearBtn = document.getElementById("clear");

    const phraseMap = [
      { en: "hello", mn: "Bello!" },
      { en: "goodbye", mn: "Poopaye!" },
      { en: "thank you", mn: "Bank yu!" },
      { en: "i'm hungry", mn: "Me want banana!" },
      { en: "i am hungry", mn: "Me want banana!" },
      { en: "i swear", mn: "Underwear" },
      { en: "fire", mn: "Bee Do!" },
      { en: "i hate you", mn: "Tatata bala tu!" },
      { en: "we love you", mn: "Tulalilloo ti amo" },
      { en: "toy", mn: "Baboi" },
      { en: "what", mn: "Po ka" },
      { en: "apple", mn: "Bable" },
      { en: "bapple", mn: "Bable" },
      { en: "ice cream", mn: "Gelato" },
      { en: "butt", mn: "Butt" },
      { en: "one", mn: "Nah" },
      { en: "two", mn: "Dul" },
      { en: "three", mn: "Sae" },
      { en: "for you", mn: "Para tu" },
      { en: "chair", mn: "Chasy" },
      { en: "cheers", mn: "Kan pai!" },
      { en: "can we start", mn: "Pwede na" },
      { en: "look at you", mn: "Luk at tu!" },
      { en: "kiss", mn: "Muak Muak" },
      { en: "i'm sorry", mn: "Ditto" },
      { en: "i am sorry", mn: "Ditto" },
      { en: "sorry", mn: "Bi-do" },
      { en: "bottom", mn: "Buttom" },
      { en: "stop", mn: "Stopa!" },
      { en: "how dare you", mn: "Sa la ka!" },
      { en: "marriage", mn: "La boda" },
      { en: "ugly", mn: "Banananonina" }
    ];

    const gibberishSyllables = [
      "ba", "ca", "da", "la", "ma", "na", "pa", "ra", "sa", "ta", "sta",
      "di", "ki", "mi", "ni", "chi",
      "bo", "do", "fo", "mo", "no", "ro", "so", "to",
      "bu", "du", "lu", "mu", "nu", "ru", "su", "tu"
    ];

    const sprinkleWords = [
      "gelato", "amigo", "bonjour", "ciao", "hola", "kampai", "sayonara", "merci"
    ];

    function preserveCase(original, replacement) {
      if (!original) return replacement;
      const first = original.charAt(0);
      if (first === first.toUpperCase()) {
        return replacement.charAt(0).toUpperCase() + replacement.slice(1);
      }
      return replacement;
    }

    function randomFrom(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    function makeGibberish(word) {
      const length = Math.max(2, Math.min(4, Math.ceil(word.length / 3)));
      let out = "";
      for (let i = 0; i < length; i += 1) {
        out += randomFrom(gibberishSyllables);
      }
      return out;
    }

    function toMinion(text) {
      if (!text.trim()) return "";

      let result = text;

      const sorted = [...phraseMap].sort((a, b) => b.en.length - a.en.length);
      for (const entry of sorted) {
        const pattern = new RegExp(`\\b${entry.en.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&")}\\b`, "gi");
        result = result.replace(pattern, (match) => preserveCase(match, entry.mn));
      }

      const tokens = result.split(/(\s+)/);
      const transformed = tokens.map((token) => {
        if (/^\s+$/.test(token)) return token;
        const stripped = token.toLowerCase().replace(/[^a-z]/g, "");
        if (!stripped) return token;

        // If already translated by phraseMap, keep it.
        if (phraseMap.some((entry) => entry.mn.toLowerCase().startsWith(stripped))) {
          return token;
        }

        const prefix = token.match(/^[^a-zA-Z]*/)?.[0] || "";
        const suffix = token.match(/[^a-zA-Z]*$/)?.[0] || "";
        const gibberish = preserveCase(token, makeGibberish(stripped));
        return `${prefix}${gibberish}${suffix}`;
      });

      const sprinkled = [];
      for (const token of transformed) {
        sprinkled.push(token);
        if (!/^\s+$/.test(token) && Math.random() < 0.12) {
          sprinkled.push(" ");
          sprinkled.push(randomFrom(sprinkleWords));
        }
      }

      return sprinkled.join("").replace(/\s{2,}/g, " ").trim();
    }

    function handleTranslate() {
      const result = toMinion(input.value);
      output.textContent = result || "Type something to see the translation.";
    }

    translateBtn.addEventListener("click", handleTranslate);
    input.addEventListener("input", handleTranslate);

    function getBestVoice() {
      const voices = window.speechSynthesis.getVoices();
      if (!voices.length) return null;

      const preferred = voices.find((voice) =>
        /en-us|en-us/i.test(voice.lang) && /female|samantha|victoria|moira|tessa|zoe|zira/i.test(voice.name)
      );
      return preferred || voices.find((voice) => /en-us|en-uk|en/i.test(voice.lang)) || voices[0];
    }

    function speakMinion(text) {
      if (!("speechSynthesis" in window)) return false;
      window.speechSynthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      const voice = getBestVoice();
      if (voice) utterance.voice = voice;

      utterance.rate = 1.25;
      utterance.pitch = 1.8;
      utterance.volume = 1;

      window.speechSynthesis.speak(utterance);
      return true;
    }

    window.speechSynthesis?.addEventListener("voiceschanged", () => {
      // Ensure voices list is populated for the first use.
      getBestVoice();
    });

    speakBtn.addEventListener("click", () => {
      const text = output.textContent.trim();
      if (!text) return;

      const ok = speakMinion(text);
      if (!ok) {
        speakBtn.textContent = "No speech support";
        setTimeout(() => (speakBtn.textContent = "Speak"), 1200);
      }
    });

    copyBtn.addEventListener("click", async () => {
      if (!output.textContent.trim()) return;
      try {
        await navigator.clipboard.writeText(output.textContent);
        copyBtn.textContent = "Copied!";
        setTimeout(() => (copyBtn.textContent = "Copy"), 1200);
      } catch (err) {
        copyBtn.textContent = "Copy failed";
        setTimeout(() => (copyBtn.textContent = "Copy"), 1200);
      }
    });

    clearBtn.addEventListener("click", () => {
      input.value = "";
      output.textContent = "";
      input.focus();
    });

    output.textContent = "Type something to see the translation.";
  </script>
</body>
</html>
